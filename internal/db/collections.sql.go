// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: collections.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkOrgOwnsCollection = `-- name: CheckOrgOwnsCollection :one
SELECT c.id FROM collections c
JOIN organization_members om ON om.organization_id = c.organization_id
WHERE c.id = $1 AND om.user_id = $2 AND c.access_level = 'organization'
`

type CheckOrgOwnsCollectionParams struct {
	ID     int32
	UserID int32
}

func (q *Queries) CheckOrgOwnsCollection(ctx context.Context, arg CheckOrgOwnsCollectionParams) (int32, error) {
	row := q.db.QueryRow(ctx, checkOrgOwnsCollection, arg.ID, arg.UserID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const checkUserOwnsCollection = `-- name: CheckUserOwnsCollection :one
SELECT id FROM collections
WHERE id = $1 AND owner_id = $2
`

type CheckUserOwnsCollectionParams struct {
	ID      int32
	OwnerID pgtype.Int4
}

func (q *Queries) CheckUserOwnsCollection(ctx context.Context, arg CheckUserOwnsCollectionParams) (int32, error) {
	row := q.db.QueryRow(ctx, checkUserOwnsCollection, arg.ID, arg.OwnerID)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createCollection = `-- name: CreateCollection :one
INSERT INTO collections (name, data, access_level, owner_id, organization_id)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, uid, name, data, access_level, owner_id, organization_id, created_at, updated_at
`

type CreateCollectionParams struct {
	Name           string
	Data           []byte
	AccessLevel    AccessLevel
	OwnerID        pgtype.Int4
	OrganizationID pgtype.Int4
}

func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection,
		arg.Name,
		arg.Data,
		arg.AccessLevel,
		arg.OwnerID,
		arg.OrganizationID,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Name,
		&i.Data,
		&i.AccessLevel,
		&i.OwnerID,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCollection = `-- name: DeleteCollection :exec
DELETE FROM collections
WHERE id = $1
`

func (q *Queries) DeleteCollection(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteCollection, id)
	return err
}

const getCollectionByID = `-- name: GetCollectionByID :one
SELECT id, uid, name, data, access_level, owner_id, organization_id, created_at, updated_at
FROM collections
WHERE id = $1
`

func (q *Queries) GetCollectionByID(ctx context.Context, id int32) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionByID, id)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Name,
		&i.Data,
		&i.AccessLevel,
		&i.OwnerID,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCollectionByUID = `-- name: GetCollectionByUID :one
SELECT id, uid, name, data, access_level, owner_id, organization_id, created_at, updated_at
FROM collections
WHERE uid = $1
`

func (q *Queries) GetCollectionByUID(ctx context.Context, uid pgtype.UUID) (Collection, error) {
	row := q.db.QueryRow(ctx, getCollectionByUID, uid)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Name,
		&i.Data,
		&i.AccessLevel,
		&i.OwnerID,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCollection = `-- name: UpdateCollection :one
UPDATE collections
SET name = $2, data = $3, access_level = $4, organization_id = $5, updated_at = now()
WHERE id = $1
RETURNING id, uid, name, data, access_level, owner_id, organization_id, created_at, updated_at
`

type UpdateCollectionParams struct {
	ID             int32
	Name           string
	Data           []byte
	AccessLevel    AccessLevel
	OrganizationID pgtype.Int4
}

func (q *Queries) UpdateCollection(ctx context.Context, arg UpdateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, updateCollection,
		arg.ID,
		arg.Name,
		arg.Data,
		arg.AccessLevel,
		arg.OrganizationID,
	)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Name,
		&i.Data,
		&i.AccessLevel,
		&i.OwnerID,
		&i.OrganizationID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
